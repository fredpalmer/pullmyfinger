#!/usr/bin/env bash
#--------------------------------------------------------------------------------------------------
# Title:        pullmyfinger
# Author:       Fred Palmer (fred@studionow.com)
# Date:         2012.02.01
# Purpose:      Make pull requests easier and quicker to accomplish as well as facilitate better
#               Github integration.
#
# Installation:
#               Source this script or add the following line to your .bashrc or .bash_profile
#                   source <path to where it will live>/pullmyfinger
#               Set the following environment variables (also in your .bashrc or .bash_profile):
#                   GITHUB_LOGIN=<your github login name>
#                   GITHUB_PASSWORD=<your github password>
#
# More Information:
#               https://github.com/fredpalmer/pullmyfinger
#               http://developer.github.com/v3/
#--------------------------------------------------------------------------------------------------
__PULLMYFINGER_VERSION="0.9"

__pmf_display_version() {
    echo "pullmyfinger ${__PULLMYFINGER_VERSION}

Copyright 2012  Fred Palmer <fred@studionow.com>
    https://github.com/fredpalmer/pullmyfinger
"
}

__pmf_display_usage() {
    echo "
Usage: pullmyfinger [OPTION] branch|remote

Config:
    Uses the following environment variables:
    GITHUB_LOGIN                A valid Github login (Required)
    GITHUB_PASSWORD             A valid password for the Github login (Required)
    PULLMYFINGER_SIGNATURE      The signature to put at the end of a pull request message (Optional)

Examples:

    # Create a pull request to the remote \"studionow\" using the base (i.e. the target branch) of \"master\"
    pullmyfinger studionow/master

    # List all pull requests to the remote \"studionow\" for the current clone
    pullmyfinger --list-pull-requests studionow

General:
    -h, --help                  Show this help text
    -v, --version               Display version
    --debug                     Displays debugging information
    --base                      Explicitly set the base (or target) branch for a pull request
    --head                      Explicitly set the head (or source) branch for a pull request

Get various types of data associated with a repo:
    --list-pull-requests        List open pull requests for the remote specified
    --list-milestones           List open milestones

Report bugs to <fred@studionow.com>
"

    __pmf_display_version

    return 0;
}

__pmf_github_get_github_user() {
    local remote_name project github_user
    remote_name=$1
    project=$(\git config --get remote.${remote_name}.url)
    project=${project##*:}
    github_user=${project%%/*}
    echo "${github_user}"
}

__pmf_github_get_api_url() {
    local remote_name project github_user request_type
    remote_name=$1
    request_type=$2

    # Get project name from git config
    project=$(\git config --get remote.${remote_name}.url)
    project=${project##*:}
    github_user=${project%%/*}
    project=${project##*/}
    project=${project%.git}
    echo "https://api.github.com/repos/${github_user}/${project}/${request_type}"
}

__pmf_validate_git_ref_exists() {
    local return_code git_ref
    git_ref=$1
    return_code=0

    # Validate the argument is a valid git-ref
    if ! \git rev-parse --verify --quiet "${git_ref}" > /dev/null
    then
        echo "ERROR => The target (base) branch \"${git_ref}\" could not be verified as a valid git reference..."
        return_code=1
    fi

    return ${return_code}
}

__pmf_github_create_pull_request() {
    local return_code command script_arg commit_message \
          base_branch base_remote_alias base_remote_true_name \
          head_branch head_remote_alias head_remote_true_name \
          github_output github_api_url github_url github_pull_request_number github_error_message github_pull_request_payload

    return_code=1
    base_branch=$1

    for script_arg in "$@";
    do
        # Strip all dashes from the commands
        command="${script_arg#--}"

        case "${command}" in
            base=*)
                base_branch="${command#*=}"
                ;;
            head=*)
                head_branch="${command#*=}"
                ;;
        esac
    done;

    # Validate the argument is a branch
    if ! __pmf_validate_git_ref_exists "${base_branch}"
    then
        return $?
    fi

    if [[ -z ${head_branch} ]]
    then
        # Get the symbolic name for the branch we are currently on (this is the most common usage)
        head_branch="$(\git symbolic-ref HEAD 2>/dev/null)"
        # remove refs/heads/ from the branch name
        head_branch="${head_branch#refs/heads/}"
        head_remote_alias="${GITHUB_LOGIN}"
        head_remote_true_name="${GITHUB_LOGIN}"
    else
        # Validate the argument is a branch
        if ! __pmf_validate_git_ref_exists "${head_branch}"
        then
            return $?
        fi

        # We need to get the repo alias name from the head branch argument
        head_remote_alias="${head_branch%%/*}"
        head_remote_true_name=$(__pmf_github_get_github_user ${head_remote_alias})
        # Strip the remote off the head_branch
        head_branch="${head_branch#*/}"
    fi

    # Get the last commit message from the branch we are using as the head branch
    commit_message=$(\git show -s --format=%s "${head_remote_alias}/${head_branch}" | sed -e 's/"//g')

    # We need to get the repo alias name from the base branch argument
    base_remote_alias="${base_branch%%/*}"
    base_remote_true_name=$(__pmf_github_get_github_user ${base_remote_alias})
    # Strip the remote off the base_branch
    base_branch="${base_branch#*/}"

    # Validate that we aren't trying to make a request from and to the same place
    if [[ "${base_remote_true_name}/${base_branch}" == "${head_remote_true_name}/${head_branch}" ]]
    then
        echo "ERROR => The target (base) and source (head) may not be the same thing..."
        return 99;
    fi

    github_api_url=$(__pmf_github_get_api_url ${base_remote_alias} "pulls")
    github_pull_request_payload="{
    \"title\": \"Pull request to ${base_remote_true_name}/${base_branch} from ${head_remote_true_name}/${head_branch#refs/heads/}\",
    \"body\": \"Please pull these commits into ${base_remote_true_name}/${base_branch}.  Here is the latest commit message:\n\n*\\\"${commit_message}\\\"*\n\n${PULLMYFINGER_SIGNATURE}\",
    \"head\": \"${head_remote_true_name}:${head_branch}\",
    \"base\": \"${base_remote_true_name}:${base_branch}\"
}"
    
    echo "Initiating Github API request with the following configuration:"
    echo "    Base (target) branch   => ${base_remote_true_name}/${base_branch}"
    echo "    Head (source) branch   => ${head_remote_true_name}/${head_branch}"
    echo "    Github Url             => ${github_api_url}"

    github_output=$(\curl                           \
        --silent                                    \
        --show-error                                \
        --request POST                              \
        --header "Content-type: application/json"   \
        --user "${GITHUB_LOGIN}:${GITHUB_PASSWORD}" \
        --data "${github_pull_request_payload}"                         \
        ${github_api_url})

    if [[ -z "${github_output}" ]]
    then
        echo -e "ERROR => Pull request failed to create :( \n\n${github_output}"
    else
        # Now make sure we didn't have an error message returned
        github_error_message=$(echo "${github_output}" | \python -c "import json;import sys;obj=json.load(sys.stdin);print obj['message']" 2>/dev/null)
        if [[ -z ${github_error_message} ]]
        then
            github_url=$(echo "${github_output}" | \python -c "import json;import sys;obj=json.load(sys.stdin);print obj['html_url']")
            github_pull_request_number=$(echo "${github_output}" | \python -c "import json;import sys;obj=json.load(sys.stdin);print obj['number']")
            echo "Pull request ${github_pull_request_number} was created successfully at ${github_url}"
            \open ${github_url}
            return_code=0
        else
            echo -e "\n\nERROR => Pull request failed to create because \"${github_error_message}\".  Here's the full output =>"
            echo "${github_output}" | python -m json.tool
        fi
    fi

    return ${return_code}
}

__pmf_github_list_item_type() {
    local remote_name git_hub_api_url item_type github_api_url
    remote_name=$1
    item_type=$2

    # Validate number and content of arguments
    (( "$#" < 2 )) || [[ -z "${remote_name}" ]] && {
        echo "ERROR => Could not determine remote name for api request...";
        return 99;
    }
    [[ -z "${item_type}" ]] && { echo "ERROR => Could not determine item type of api request..."; return 99; }

    github_api_url=$(__pmf_github_get_api_url ${remote_name} ${item_type})

    echo "Initiating Github API ${item_type} request with the following configuration:"
    echo "    Remote name   => ${remote_name}"
    echo "    Github Url    => ${github_api_url}"

    \curl --silent --user "${GITHUB_LOGIN}:${GITHUB_PASSWORD}" ${github_api_url} | python -m json.tool
}

__pmf_validate_environment() {
    local return_code
    return_code=0

    # Verify environment variables are set
    [[ -z ${GITHUB_LOGIN} ]] && { echo "ERROR => \"GITHUB_LOGIN\" env variable was not set..."; return_code=99; }
    [[ -z ${GITHUB_PASSWORD} ]] && { echo "ERROR => \"GITHUB_PASSWORD\" env variable was not set..."; return_code=99; }

    # Verify git exists
    type -P git >/dev/null || { echo "ERROR => The program \"git\" was not found in the current PATH..."; return_code=99; }

    # Verify curl exists
    type -P curl >/dev/null || { echo "ERROR => The program \"curl\" was not found in the current PATH..."; return_code=99; }

    return ${return_code}
}

__pmf_gateway() {
    local command return_value debug_mode script_arg filtered_options
    debug_mode=0
    return_value=0

    for script_arg in "$@";
    do
        # Strip all dashes from the commands
        command="${script_arg#--}"
        command="${command#-}"

        case "${command}" in
            help|h)
                __pmf_display_usage;
                return $?;
                ;;
            version|v)
                __pmf_display_version;
                return $?;
                ;;
            debug)
                debug_mode=1;
                ;;
            *)
                filtered_options=( "${filtered_options[@]}" "${command}" )
                ;;
        esac
    done

    # Turn on debug mode if it was requested
    (( ${debug_mode} )) && { echo "Turning on debug mode..."; set -x; }

    if __pmf_validate_environment
    then
        for script_arg in "${filtered_options[@]}";
        do
            case "${script_arg}" in
                list-pull-requests)
                    # Pop the command argument we just parsed - we don't need to pass it to the handler
                    shift && __pmf_github_list_item_type "${filtered_options[@]}" "pulls?state=open" || { return_value=$?; }
                    break;
                    ;;
                list-milestones)
                    # Pop the command argument we just parsed - we don't need to pass it to the handler
                    shift && __pmf_github_list_item_type "${filtered_options[@]}" "milestones?state=open" || { return_value=$?; }
                    break;
                    ;;
                *)
                    __pmf_github_create_pull_request "${filtered_options[@]}" || { return_value=$?; }
                    break;
                    ;;
            esac
        done
    else
        echo "WTF"
    fi

    # Turn off debug mode if we turned it on previously
    (( ${debug_mode} )) && { echo "Turning off debug mode..."; set +x; }

    return ${return_value}
}

__pmf_completion() {
    local current_word previous_word previous_word2 completion_options
    COMPREPLY=()
    current_word="${COMP_WORDS[COMP_CWORD]}"
    previous_word="${COMP_WORDS[COMP_CWORD-1]}"

    if [[ ${#COMP_WORDS[@]} -gt 2 ]]
    then
        previous_word2="${COMP_WORDS[COMP_CWORD-2]}"
    else
        previous_word2=""
    fi

    current_word="${COMP_WORDS[COMP_CWORD]}"
    previous_word="${COMP_WORDS[COMP_CWORD-1]}"

    if [[ ${current_word} =~ ^--(base|head).* ]] || \
       [[ ${current_word} == "=" && ${previous_word} =~ ^--(base|head).* ]] || \
       [[ ${previous_word2} =~ ^--(base|head) ]]
    then
        # User is trying to manually specify the base and head for a pull request and
        # has completed setting the --head and/or --base option and needs to auto-complete
        # the remote branch to use as the option's value

        # filter out previous branches selected
        previous_word=${previous_word#--base}
        previous_word=${previous_word#--head}
        previous_word=${previous_word#=}
        # On older versions of bash this will be the branch name that was previously selected
        # On newer versions of bash this will be blank
        if [[ "${previous_word}" != "" ]]
        then
            completion_options=$(\git branch -r | \grep -v "HEAD" | \grep -v ${previous_word})
        else
            if [[ ${previous_word2} =~ ^--(base|head) ]] && (( ${COMP_CWORD} > 4 ))
            then
                completion_options=$(\git branch -r | \grep -v "HEAD" | \grep -v ${COMP_WORDS[3]})
            else
                completion_options=$(\git branch -r | \grep -v "HEAD")
            fi
        fi

        # massage what's matched so its (compatible with older versions of bash)
        current_word=${current_word#--base}
        current_word=${current_word#--head}
        current_word=${current_word#=}
    elif [[ "${COMP_LINE}" == *--base=* && ${COMP_LINE} != *--head=* ]]
    then
        # User is trying to manually specify the base and head for a pull request and
        # has completed setting the --base option and now
        # we can automatically fill in the --head part and start
        # command line completion for it as well
        completion_options="--head="
    elif [[ "${COMP_LINE}" == *--head=* && ${COMP_LINE} != *--base=* ]]
    then
        # User is trying to manually specify the base and head for a pull request and
        # has completed setting the --head option and now
        # we can automatically fill in the --base part and start
        # command line completion for it as well
        completion_options="--base="
    elif [[ ${previous_word} == --list-* ]]
    then
        # User is trying to use one of the "list" read-only style commands and needs
        # to autocomplete with the configured remotes for the current working clone
        completion_options=$(\git remote show)
    elif (( ${COMP_CWORD} < 2))
    then
        if [[ ${current_word} == -* ]]
        then
            # User is trying to specify the command line directive to use
            completion_options="--help --debug --base= --head= --version --list-pull-requests --list-milestones"
            COMPREPLY=( $(compgen -W "${completion_options}" -- ${current_word}) )
        elif [[ "${COMP_LINE}" != *--* ]]
        then
            # User is trying to specify the remote branch to issue a pull request to
            completion_options=$(\git branch -r | \grep -v "HEAD")
        fi
    fi

    COMPREPLY=( $(compgen -W "${completion_options}" -- ${current_word}) )
    [[ ${COMPREPLY} == *= ]] && compopt -o nospace

    return 0;
}

alias pullmyfinger=__pmf_gateway
complete -F __pmf_completion pullmyfinger

# Also run the completion scripts for any aliases out there
for aliased_command in $(\alias | \grep "='pullmyfinger'" | \cut -d ' ' -f2 | \cut -d '=' -f1)
do
    complete -F __pmf_completion ${aliased_command}
done
